\documentclass[draft,12pt]{llncs}   % TODO: change this to Springer format

\include{prelude}

\begin{document}

\maketitle

\begin{abstract}
  Genetic Programming has a variety of benefits over other learning paradigms
  for the purposes of explainability and versitility. Recently, a growing
  application area has been the genetic writing and improvement of computer
  programs. This paper demonstrates that this goal can be achieved through
  application of the genetic programming paradigm using a novel technique,
  called \emph{process fuzzing}, and presents an implementation of this in
  PyDySoFu.
\end{abstract}


\section{Evolving Programs}
Genetic Programming (GP) is a very well-established and promising field which
has returned impressive results in a number of areas. The field has spawned a
number of similar approaches which, while based on the same underlying concept,
approach an evolution-based solution in novel ways.\par

Cartesian GP\cite{miller1999empirical,miller2011cartesian} uses a directed
graph, rather than a tree, to represent a solution to a problem, and has seen
great success, particularly for its ability to converge on an acceptable
solution in a relatively short number of generations. Stack-based
GP\cite{perkis1994stack} is a method which employs the use of stacks so as to
push/pop values of different types. This has the advantage of being able to work
with state, which can be difficult for the traditional tree-based genetic
programming (TGP) approach.\par

\subsection{Genetic Metaprogramming}
Not all variants of GP present methods for improving mathematical-looking
functions to fit some goal function, however. Variants have begun to arise
which, rather than mutating some abstract representation of a program, mutate
the program itself. \footnote{As no term for this specific category of GP
  approaches seems to have been coined, they will be referred to here as
  ``genetic metaprogramming''.} Stack-based GP in the Push family of
languages\cite{spector2001autoconstructive}, for example, feature an approach
where values on stacks can be code, which can be subsequently executed; in this
way, Stack-based GP can be used to achieve a kind of metaprogramming with a
genetic approach. Similarly, Linear Genetic Programming\cite{brameier2007linear}
(LGP) is a method which evolves a series of instructions, rather than a tree of
operations, to achieve a solution.\par

Indeed, approaches involving the alteration of source code have garnered a
growing amount of attention: in the improvement of Java programs alone, several
tools for the improvement of a codebase have
arisen\cite{cody2015locogp,arcuri2008multi,orlov2011flight,castle2012evolving}.
As well as improving codebases, genetic metaprogramming could be used to
implement standard problems in GP such as symbolic regression, by constructing
imperative processes that fit a curve, rather than the traditional tree
representation from TGP\cite{koza1994genetic}.
\par


\section{Approaches with Dynamic Fuzzing}
\label{sec:dynamic_fuzzing}
\subsection{The Technology}
\todo{Flesh out with more of our method. Make the paper more about showing off
  what we've got, rather than justifying that it's like what other people do.}
Altering source code can be done in a variety of ways, depending on a process'
representation. In \cite{wallis2018a}, a general purpose technique for altering
code prior to execution is demonstrated for the purposes of injecting
``mistakes'' into a model of software development workflows.\par

The technique works by catching function calls prior to execution. The AST of
the original function is captured, modified using an arbitrary alteration
function, and the result run instead of the original. Every time the target
function is run, then, a slightly altered variant is run in its place. In
\cite{wallis2018a}, this is used to represent ``mistakes'' in a workflow
simulation of software engineers.\par

Conceivably, these behaviours could be considered ``improvements'' on the
original workflow design, depending on the perspective. Some changes might make
the workflow more resilient against the mistakes of other agents. What
constitutes an improvement, rather than a mistake, is dependent on some sort of
metric of ``goodness'' --- a clear analogy to fitness functions used in GP can be
seen.\par

\subsection{Genetic Programming using Dynamic Fuzzing}
three improvements on the design of the process fuzzing in \cite{wallis2018a}
permit the implementation of GP in the process fuzzing library
PyDySoFu\cite{pydysofu}: first, process fuzzers (``fuzzers'') can now generate
and keep track of multiple variants of a function and their results, and second,
fuzzers can improve on those variants by comparing their results against success
metrics. A third addition --- the recombination of ASTs to generate new
offspring --- provides GP-style interactions via process fuzzing.\par

\subsection{Incremental Improvers}

Implementing the first two of these features is the \texttt{IncrementalImprover}
fuzzing aspect class found in the repository at \cite{pydysofu} (example
ommitted for space reasons). This fuzzer allows the provision of success metrics
for fuzzing targets, using different lengths of rounds and different numbers of
variants per round for improved search. \par

Importantly, the fuzzer can be adapted simply by constructing a subclass which
overrides methods representing behaviour to be changed. This allows improvements
and small tweaks to the ordinary behaviour of a fuzzer to be implemented simply.
For example, one modular component of the \texttt{IncrementalImprover} is how it
ranks variants. To rank in descending order against a success metric (analogous
to GP's fitness functions) where success is considered to be far away from
``\texttt{0}'':

\begin{figure}
  \centering
  \begin{lstlisting}
  from pydysofu import IncrementalImprover

  class SortkeyOverridingImprover(IncrementalImprover):
      def sort_key(self, result):
          '''
          :param result: a tuple of the form:
          (variant, mean of variant's success metric values)
          :return: a value used to rank this pair
          '''
          actual_result = result[1]
          return -abs(actual_result) #-ve for descending order
  \end{lstlisting}
  \caption{Overriding a sort key for ranking variants}
  \label{fig:sort_key_override}
\end{figure}
\todo{Decide whether to keep this in, add more code snippets, or remove them altogether}

% The architecture of PyDySoFu is structured so that changes to fuzzers can be
% implemented as minor implementation details, by separating the concerns of
% an approach or application of the technology to a given problem domain into
% methods which can be overwritten. This minimises the amount of code required for
% tailoring the use of PyDySoFu to a given problem domain.

The architectural decision to modularise different components of a fuzzer's
behaviour allows for extension of a fuzzer's behaviour and improvements on its
ordinary capabilities with minimal additional work. This facilitates the
implementation of new techniques while utilising the capacities of existing
fuzzers.\par

\subsection{Genetic Improvers}

The approach has been extended to allow a GP style approach by fuzzing ASTs, a
technique already proven in Java\cite{castle2012evolving,cody2015locogp}. This
is done by extending the \texttt{IncrementalImprover} into a
\texttt{GeneticImprover} by updating its construction of a new ``round'' of
variants, so as to allow the splicing of ASTs with a \texttt{splice} method on
the fuzzer.\todo{update ``splice'' here to be an inline listings thing?} This
can be overwritten in much the same way as the sort key is in
\cref{fig:sort_key_override}.

By way of showing that the interactions required of GP can be found in this
method, an implementation of a symbolic regression using standard functions
found in \cite{koza1994genetic} can be found in
\cite{pydysofu} as a unit test. An implementation of the Santa Fe Ant problem is
also underway.

\subsection{Benefits of the Approach}
Use of PyDySoFu as a GP solution has a number of advantages. First, it is under
active development, meaning that the tool can be expected to improve. Users can
anticipate PyDySoFu to be a fertile ground for new research, where process
fuzzing can be used to separate concerns in a variety of fields\par

Importantly, PyDySoFu just a tool for implementing solutions to GP problems. Its
versatility is a second benefit: its most active area of study, socio-technical
variance, provides a plethora of problem domains where GP might find
applications. Research involving the construction of a model of a problem domain
comes with an additional associated time cost; as libraries of case studies are
developed and verified for sociotechnical variance research which fit a
PyDySoFu-esque modelling technique, applications of genetic programming
naturally arise. this is explored further is \cref{sec:future_work}.\par

Further, PyDySoFu is able to fuzz code \emph{dynamically}, by which we mean that variants
of a function can be generated \emph{every time that function is called}. As GP
techniques are increasingly used to improve codebases, this functionality can be
used to perform experiments with GP solutions which might --- for example ---
use dynamic fuzzing to represent solutions which operate in an unreliable real
world, such as an unreliable network or anomalies in animal populations.\par

\section{Future Work}
\label{sec:future_work}

PyDySoFu is a new entrant into tools for running experiments within GP, with the
unusual trait that its suitability for evaluating GP problems comes from its
versatility, rather than being developed specifically for the field.\par

A result of this is that PyDySoFu is poised to be an unusually effective tool in
a variety of fields. Many things can be done to increase PyDySoFu's
effectiveness as a GP tool, and to exploit PyDySoFu's versitility to explore new
research possibilities, including:

\begin{itemize}
\item A wider array of GP-style fuzzers can be implemented, building on the
  broad array of code improving GP approaches surfacing in the literature.

\item Replication of existing studies in GP would assist the development of more
GP-style fuzzers, as well as more concretely validating PyDySoFu as a tool for
GP.
  
\item As socio-technical models surface, GP-style improvement of a problem
  domain is an exciting research opportunity. For example: in a scenario where
  models of socio-technical variance are developed, GP techniques could be
  employed to explore ``better'' socio-technical systems which, when exposed to
  that variance, are more resilient to stress, safer, or more efficient, as well
  as uncountable other meta-heuristics. This benefits from GP's explainability,
  as each ``improvement'' of the problem domain (application of a fuzzer) leaves
  a trace showing how a real-world system might be improved.

\item Further exploration of GP using AST-style improvement for codebase
  improvement can also be explored in Python using PyDySoFu, which, combined
  with the other research opportunities, makes it an exciting alternative to
  existing solutions.
\end{itemize}


\section{Conclusion}
This paper has given a brief overview of recent development of PyDySoFu, a
process fuzzing tool which is now capable of GP-style interactions. While
GP-style interactions arising from process fuzzing is an interesting result of
its own, the availability of the tool is hoped to inspire further work in the
area, and help to contribute to the growing literature on genetic
metaprogramming.\par


\bibliography{lib}
\end{document}